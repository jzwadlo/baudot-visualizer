<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baudot Code Visualization (SVG Export)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color, #1A2046); /* Use CSS variable for background */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            color: #cbd5e0; /* Default text color for dark background */
            transition: background-color 0.3s ease; /* Smooth background transition */
        }

        body.no-background {
            background-color: #ffffff; /* White background when toggled off */
            color: #333; /* Darker text for readability on white */
        }

        h2 {
            color: inherit; /* Inherit color from body */
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-align: center;
            width: 100%;
        }

        .controls-container {
            background-color: #2d3748;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 40px;
            width: 95%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        body.no-background .controls-container {
             background-color: #e2e8f0; /* Lighter background for controls in light mode */
        }


        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            margin-bottom: 5px;
            font-weight: bold;
            color: inherit; /* Inherit color from parent (controls-container or body) */
        }

        .control-group input[type="text"],
        .control-group input[type="range"],
        .control-group input[type="color"],
        .control-group textarea {
            padding: 8px;
            border-radius: 4px;
            border: none;
            background-color: #4a5568; /* Darker input background */
            color: #e2e8f0; /* Light input text color */
        }

         body.no-background .control-group input[type="text"],
         body.no-background .control-group input[type="range"],
         body.no-background .control-group input[type="color"],
         body.no-background .control-group textarea {
             background-color: #cbd5e0; /* Lighter input background in light mode */
             color: #333; /* Dark input text color in light mode */
         }


         .control-group textarea {
             min-height: 60px;
         }


        .control-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            cursor: pointer;
            outline: none;
        }

         .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: #63b3ed;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -3.5px;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: #63b3ed;
            border-radius: 50%;
            cursor: pointer;
        }


        .control-group input[type="checkbox"] {
            margin-right: 5px;
        }

        .visualization-container {
            /* No flexbox needed here as SVG handles positioning */
            margin-bottom: 20px;
        }

        /* Styling for the color picker group */
        .color-picker-group {
            display: flex;
            gap: 10px; /* Space between color pickers */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center;
        }

        .color-picker-group input[type="color"] {
            padding: 5px; /* Adjust padding for color pickers */
            height: 35px; /* Set a consistent height */
        }

        .export-button {
            background-color: #63b3ed;
            color: #1a202c;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .export-button:hover {
            background-color: #4299e1;
        }

        .export-options {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

    </style>
</head>
<body>

    <h2>Baudot Code Visualization (SVG Export)</h2>

    <div class="controls-container">
        <div class="control-group">
            <label for="input-word">Enter Word:</label>
            <input type="text" id="input-word" value="COLDPLAY">
        </div>

        <div class="control-group">
            <label for="block-spacing">Block Spacing (Vertical):</label>
            <input type="range" id="block-spacing" min="-5" max="10" value="0">
        </div>

         <div class="control-group">
            <label for="character-spacing">Character Spacing (Horizontal):</label>
            <input type="range" id="character-spacing" min="-20" max="50" value="15">
        </div>

         <div class="control-group">
            <label for="block-width">Block Width:</label>
            <input type="range" id="block-width" min="10" max="80" value="40">
        </div>

         <div class="control-group">
            <label for="block-height">Block Height:</label>
            <input type="range" id="block-height" min="10" max="80" value="40">
        </div>

        <div class="control-group">
            <label>Custom Color Palette:</label>
            <div class="color-picker-group">
                <input type="color" id="color-palette-1" value="#A0A0A0">
                <input type="color" id="color-palette-2" value="#FFFFFF">
                <input type="color" id="color-palette-3" value="#CC3333">
                <input type="color" id="color-palette-4" value="#DD9933">
                <input type="color" id="color-palette-5" value="#336633">
            </div>
        </div>

        <div class="control-group">
            <label for="color-randomness">Color Randomness:</label>
            <input type="range" id="color-randomness" min="0" max="100" value="0">
        </div>

         <div class="control-group">
            <label for="background-color-picker">Solid Background Color:</label>
            <input type="color" id="background-color-picker" value="#1A2046">
        </div>


        <div class="control-group">
            <label for="toggle-background">Toggle Dark Background:</label>
            <input type="checkbox" id="toggle-background" checked>
        </div>

         <div class="control-group">
            <label for="toggle-annotations">Toggle Annotations (Labels):</label>
            <input type="checkbox" id="toggle-annotations" checked>
        </div>


        <div class="control-group">
            <button id="export-svg-button" class="export-button">Export as SVG</button>
            <div class="export-options">
                 <input type="checkbox" id="transparent-background-export">
                 <label for="transparent-background-export">Transparent Background on Export</label>
            </div>
        </div>
    </div>

    <div id="visualization" class="visualization-container">
        <svg id="baudot-svg"></svg>
    </div>

    <script>
        // Baudot Code Mapping (International Telegraph Alphabet No. 2 - ITA2)
        // This is a standard and widely recognized 5-bit code.
        const baudotCode = {
            'A': [0, 0, 0, 1, 1], // 3
            'B': [1, 1, 0, 0, 1], // 25
            'C': [0, 1, 1, 1, 0], // 14
            'D': [0, 1, 0, 0, 1], // 9
            'E': [0, 0, 0, 0, 1], // 1
            'F': [0, 1, 1, 0, 1], // 13
            'G': [1, 1, 0, 1, 0], // 26
            'H': [1, 0, 1, 0, 0], // 20
            'I': [0, 0, 1, 1, 0], // 6
            'J': [0, 1, 1, 0, 0], // 12
            'K': [0, 1, 1, 1, 1], // 15
            'L': [1, 0, 0, 1, 0], // 18
            'M': [1, 1, 1, 0, 0], // 28
            'N': [1, 1, 0, 0, 0], // 24
            'O': [1, 0, 1, 1, 0], // 22
            'P': [1, 0, 1, 1, 1], // 23
            'Q': [1, 1, 1, 0, 1], // 29
            'R': [0, 1, 0, 1, 0], // 10
            'S': [0, 0, 1, 0, 1], // 5
            'T': [1, 0, 0, 0, 0], // 16
            'U': [0, 0, 1, 1, 1], // 7
            'V': [1, 1, 1, 1, 0], // 30
            'W': [1, 1, 0, 1, 1], // 27
            'X': [1, 0, 1, 0, 1], // 21
            'Y': [1, 0, 0, 1, 1], // 19
            'Z': [1, 0, 0, 0, 1], // 17
            ' ': [0, 0, 0, 1, 0], // Space
            'LS': [1, 1, 1, 1, 1], // Letters Shift (often 11111)
            'FS': [1, 1, 0, 1, 1]  // Figures Shift (often 11011)
            // Note: This mapping only includes letters and basic shifts.
            // Full ITA2 includes numbers and symbols under Figures Shift.
            // For a tattoo, typically only letters are used.
        };

        // Default X&Y Album Cover Color Palette
        const defaultColorPalette = [
            '#A0A0A0', // Bit 1 (Grey)
            '#FFFFFF', // Bit 2 (White)
            '#CC3333', // Bit 3 (Red)
            '#DD9933', // Bit 4 (Orange)
            '#336633'  // Bit 5 (Darker Green)
        ];

        const baudotSvg = document.getElementById('baudot-svg');
        const inputWordInput = document.getElementById('input-word');
        const blockSpacingSlider = document.getElementById('block-spacing');
        const characterSpacingSlider = document.getElementById('character-spacing');
        const blockWidthSlider = document.getElementById('block-width');
        const blockHeightSlider = document.getElementById('block-height');
        const colorPalettePickers = [
            document.getElementById('color-palette-1'),
            document.getElementById('color-palette-2'),
            document.getElementById('color-palette-3'),
            document.getElementById('color-palette-4'),
            document.getElementById('color-palette-5')
        ];
        const colorRandomnessSlider = document.getElementById('color-randomness');
        const backgroundColorPicker = document.getElementById('background-color-picker');
        const toggleBackgroundCheckbox = document.getElementById('toggle-background');
        const toggleAnnotationsCheckbox = document.getElementById('toggle-annotations');
        const exportSvgButton = document.getElementById('export-svg-button');
        const transparentBackgroundCheckbox = document.getElementById('transparent-background-export');
        const body = document.body;

        // Function to convert a word to Baudot code (array of bit arrays)
        function wordToBaudot(word) {
            const baudotSequence = [];
            // Always start with Letters Shift for clarity, even if the first char is LS
            baudotSequence.push(baudotCode['LS']);

            for (let i = 0; i < word.length; i++) {
                const char = word[i].toUpperCase();
                if (baudotCode[char]) {
                    baudotSequence.push(baudotCode[char]);
                } else if (char === ' ') { // Handle space explicitly
                    baudotSequence.push(baudotCode[' ']);
                } else {
                    console.warn(`Character "${word[i]}" not found in Baudot code mapping. Skipping.`);
                }
            }
            return baudotSequence;
        }

        // Function to get a color with optional randomization
        function getRandomizedColor(baseColor, randomness) {
            if (randomness === 0 || !baseColor) {
                return baseColor || '#000000';
            }

            const hexToRgb = hex => hex.match(/\w\w/g).map(x => parseInt(x, 16));
            const rgbToHex = rgb => '#' + rgb.map(x => x.toString(16).padStart(2, '0')).join('');

            let [r, g, b] = hexToRgb(baseColor);
            const amount = randomness / 100 * 50;

            r = Math.max(0, Math.min(255, r + (Math.random() - 0.5) * amount * 2));
            g = Math.max(0, Math.min(255, g + (Math.random() - 0.5) * amount * 2));
            b = Math.max(0, Math.min(255, b + (Math.random() - 0.5) * amount * 2));

            return rgbToHex([Math.round(r), Math.round(g), Math.round(b)]);
        }


        // Function to render the Baudot visualization as SVG
        function renderSvgVisualization() {
            const word = inputWordInput.value;
            const baudotData = wordToBaudot(word);
            const blockSpacing = parseInt(blockSpacingSlider.value);
            const characterSpacing = parseInt(characterSpacingSlider.value);
            const blockWidth = parseInt(blockWidthSlider.value);
            const blockHeight = parseInt(blockHeightSlider.value);
            const colorRandomness = parseInt(colorRandomnessSlider.value);
            const backgroundColor = backgroundColorPicker.value;
            const transparentBackground = transparentBackgroundCheckbox.checked;
            const showAnnotations = toggleAnnotationsCheckbox.checked;


            const customColorPalette = colorPalettePickers.map(picker => picker.value);

            // Define space needed for annotations
            const annotationPaddingTop = showAnnotations ? 30 : 0; // Space for character labels
            const annotationPaddingLeft = showAnnotations ? 40 : 0; // Space for bit labels
            const labelFontSize = 12; // Font size for labels

            // Calculate total width and height of the visualization, including annotation space
            const numCharacters = baudotData.length;
            // Ensure visualizationWidth is at least 0 for empty strings
            const visualizationWidth = numCharacters > 0 ? (numCharacters * blockWidth + (numCharacters - 1) * characterSpacing) : 0;
            const visualizationHeight = 5 * blockHeight + 4 * blockSpacing; // 5 bits per character

            const totalWidth = visualizationWidth + annotationPaddingLeft;
            const totalHeight = visualizationHeight + annotationPaddingTop;


            // Set SVG dimensions and viewBox
            baudotSvg.setAttribute('width', totalWidth);
            baudotSvg.setAttribute('height', totalHeight);
            baudotSvg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);

            // Clear previous SVG content
            baudotSvg.innerHTML = '';

            // Add background rectangle if not transparent
            if (!transparentBackground) {
                const backgroundRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                backgroundRect.setAttribute('x', 0);
                backgroundRect.setAttribute('y', 0);
                backgroundRect.setAttribute('width', totalWidth);
                backgroundRect.setAttribute('height', totalHeight);
                backgroundRect.setAttribute('fill', backgroundColor);
                baudotSvg.appendChild(backgroundRect);
            }

            // Add annotations if enabled
            if (showAnnotations) {
                 // Add character labels (top)
                 let currentLabelX = annotationPaddingLeft + blockWidth / 2;
                 for (let i = 0; i < numCharacters; i++) {
                     const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                     text.setAttribute('x', currentLabelX);
                     text.setAttribute('y', annotationPaddingTop - 10); // Position above the blocks
                     text.setAttribute('text-anchor', 'middle'); // Center text above the block
                     text.setAttribute('font-size', labelFontSize);
                     text.setAttribute('fill', body.classList.contains('no-background') ? '#333' : '#e2e8f0'); // Adjust color based on background
                     // Determine the character for the label
                     let charForLabel;
                     if (i === 0) {
                         charForLabel = 'LS'; // First column is always Letters Shift
                     } else if (word[i - 1] === ' ') {
                         charForLabel = 'SP'; // Indicate Space
                     } else {
                         charForLabel = word[i - 1].toUpperCase();
                     }
                     text.textContent = charForLabel;
                     baudotSvg.appendChild(text);

                     currentLabelX += blockWidth + characterSpacing;
                 }

                 // Add bit labels (left)
                 let currentLabelY = annotationPaddingTop + blockHeight / 2 + labelFontSize / 3; // Center vertically
                 for (let i = 0; i < 5; i++) {
                     const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                     text.setAttribute('x', annotationPaddingLeft - 10); // Position to the left of the blocks
                     text.setAttribute('y', currentLabelY);
                     text.setAttribute('text-anchor', 'end'); // Align text to the right
                      text.setAttribute('font-size', labelFontSize);
                     text.setAttribute('fill', body.classList.contains('no-background') ? '#333' : '#e2e8f0'); // Adjust color based on background
                     text.textContent = `Bit ${i + 1}`;
                     baudotSvg.appendChild(text);

                     currentLabelY += blockHeight + blockSpacing;
                 }
            }


            let currentX = annotationPaddingLeft; // Start drawing blocks after annotation space
            let currentY;

            baudotData.forEach((charBits, charIndex) => {
                currentY = annotationPaddingTop; // Start drawing blocks after annotation space

                charBits.forEach((bit, bitIndex) => {
                    if (bit === 1) {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', currentX);
                        rect.setAttribute('y', currentY);
                        rect.setAttribute('width', blockWidth);
                        rect.setAttribute('height', blockHeight);

                        const baseColor = customColorPalette[bitIndex];
                        rect.setAttribute('fill', getRandomizedColor(baseColor, colorRandomness));

                        baudotSvg.appendChild(rect);
                    }

                    currentY += blockHeight + blockSpacing;
                });

                currentX += blockWidth + characterSpacing;
            });
        }

        // Function to export the SVG
        function exportSvg() {
            const svgData = new XMLSerializer().serializeToString(baudotSvg);
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'baudot_visualization.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Clean up
        }


        // Event Listeners for controls
        inputWordInput.addEventListener('input', renderSvgVisualization);
        blockSpacingSlider.addEventListener('input', renderSvgVisualization);
        characterSpacingSlider.addEventListener('input', renderSvgVisualization);
        blockWidthSlider.addEventListener('input', renderSvgVisualization);
        blockHeightSlider.addEventListener('input', renderSvgVisualization);
        colorPalettePickers.forEach(picker => {
            picker.addEventListener('input', renderSvgVisualization);
        });
        colorRandomnessSlider.addEventListener('input', renderSvgVisualization);
        backgroundColorPicker.addEventListener('input', renderSvgVisualization);
        toggleBackgroundCheckbox.addEventListener('change', () => {
            body.classList.toggle('no-background', !toggleBackgroundCheckbox.checked);
             // Re-render the SVG to update background display and label colors
            renderSvgVisualization();
        });
        toggleAnnotationsCheckbox.addEventListener('change', renderSvgVisualization); // Re-render when annotations are toggled
        transparentBackgroundCheckbox.addEventListener('change', renderSvgVisualization); // Re-render when transparent export is toggled


        // Export button listener
        exportSvgButton.addEventListener('click', exportSvg);


        // Initial render
        renderSvgVisualization();
        // Set initial background state based on checkbox
        body.classList.toggle('no-background', !toggleBackgroundCheckbox.checked);


    </script>

</body>
</html>
